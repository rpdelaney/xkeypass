#!/usr/bin/env bash
# GNU bash, version 4.3.8(1)-release (x86_64-unknown-linux-gnu)
#
# © Copyright 2014 Ryan Delaney.
# This work is distributed WITHOUT ANY WARRANTY whatsoever; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the README file for additional terms and conditions on your use of this
# software.
#
# TODO: Collapse multiple invocations of `shift` using `shift INT`

# Functions {{{1
verbose() {
  if [[ "$verbose" -gt "0" ]]; then
    echo "$1" >&2
  fi
}

error() {
  echo "$1" >&2
}

cleanup() {
  # Remove the temporary files
  verbose "Removing tmpfile: $tmpfile $tmpfile2"
  if [[ -f "$tmpfile" ]] ; then
    if ( shred "$tmpfile" "$tmpfile2" 2> /dev/null ; rm -f "$tmpfile" "$tmpfile2" ); then
      exit 0
    else
      error 'EMERGENCY! Error while cleaning temporary files!'
      error "$tmpfile"
      error "$tmpfile2"
    fi
  fi
}

getpw() {
  # Retrieve key $1 from record title $2 and store it in tmpfile $3
  local key="$1"
  local title="$2"

  if ! pass show "$title" | jshon -e "$key" -u ; then
    error "We failed to retrieve the password."
    exit 1
  fi
  cleanup
}

updatekey() {
  # Update key $1 in record title $2 using tmpfile $3 with new keyvalue $4
  key="$1"
  title="$2"
  tmpfile="$3"
  keyvalue="$4"
  epoch="$(date +%s)"

  if pass show "$title" > "$tmpfile"; then
    jshon -I -s "$keyvalue" -i "$key" -F "$tmpfile"
    jshon -I -s "$epoch" -i "updated" -F "$tmpfile"
    pass insert --multiline "$title" < "$tmpfile"
  else
    exit 1
  fi
}
# }}}
# Usage {{{1
#
usage() {
cat <<EOD
xkeypass
© Copyright 2014 Ryan Delaney.

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at your
option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

Web site: http://github.com/rpdelaney

xkeypass acts as a front-end to pass, extracting stored json data types.

Usage: xkeypass [OPTION] TITLE COMMAND KEY

Options
  -?, --help                  print this help and exit
  -v, --verbose               increase verbosity of debugging output

Commands
  a, add                      create a new record named TITLE
  d, del KEY                  delete a key from TITLE
  g, get KEY                  retrieve a key from TITLE
  s, select KEY               print TITLE in json format to standard output
  u, update KEY VALUE         update or create a key in TITLE. if VALUE is -
                              then read from standard input
  t, type KEY                 type the key with xdotool
  p, password [LENGTH]        generate a secure password using pwgen and update
                              "password" with the new value.
EOD
exit 1
}
# }}}
# Parameters {{{1
#
while :
do
  case "$1" in
    --help | -\?)
      usage
      exit 0
      ;;
    -v | --verbose)
      # Each instance of -v adds 1 to verbosity
      verbose=$((verbose+1))
      shift
      if [[ "$verbose" -ge '2' ]]; then
        set -x
      fi
      ;;
    --) # End of all options
      shift
      break
      ;;
    -*)
      error "WARNING: Ignoring unknown option: $1"
      shift
      ;;
    *)  # no more options. Stop while loop
      break
      ;;
  esac
done
# }}}
# Commands {{{1
#
  # assume that whatever comes next is the record title
title="$1"
if shift; then
  verbose "command: $@"
else
  error "FATAL: command not specified."
  exit 1
fi

while :
do
  case "$1" in
    a | add)
      add="$1"
      shift
      ;;
    d | del)
      del="$1"
      shift
      ;;
    g | get)
      get="1"
      key="$2"
      shift
      shift
      ;;
    s | select | show)
      select="1"
      key="$2"
      shift
      shift
      ;;
    u | update)
      update="1"
      key="$2"
      keyvalue="$3"
      shift
      shift
      shift
      ;;
    t | type)
      xkey="1"
      key="$2"
      shift
      shift
      ;;
    p | password)
      passgen="1"
      passlen="$2"
      shift
      shift
      ;;
    --) # End of all commands
      shift
      break
      ;;
    -*)
      error "WARNING: Ignoring unknown option: $@"
      shift
      ;;
    *)  # no more commands. Stop while loop
      break
      ;;
  esac
done
# }}}
# Input validation {{{1
  # title is not optional
if [[ -z "$title" ]]; then
  error "FATAL: record title not specified."
  exit 1
fi

if ! pass ls | grep -q "$title" && test -z "$add"; then
  # Verify that the given record title exists in password-store
  error "FATAL: record title not found."
  error "Try 'pass ls' for a list of available records."
  exit 1
fi

  # read in keyvalue
if [[ "$keyvalue" == "-" ]]; then read -r keyvalue; fi
# }}}
# Dependencies {{{1
if ! type jshon &> /dev/null; then echo "ERROR: Missing dependency: jshon" 1>&2; exit 1; fi
if ! type pass &> /dev/null; then echo "ERROR: Missing dependency: password-store" 1>&2; exit 1; fi
# }}}
# Build sandbox {{{1
tmpfile="$(mktemp --suffix=.pass)"
tmpfile2="$(mktemp --suffix=.pass)"
chmod 0600 "$tmpfile"
chmod 0600 "$tmpfile2"
verbose "tmpfile is: $tmpfile $tmpfile2"
  # Clean up before exiting for any reason whatsoever
trap 'cleanup' INT QUIT TERM EXIT 0 1 2 3 6 9 14 15
# }}}
# Debugging output {{{1
if [[ "$verbose" -ge '2' ]]; then
  set -x
  echo "get is: $get"
  echo "key is: $key"
  echo "title is: $title"
fi
# }}}
# Create {{{1
if [[ -n "$add" ]]; then
  verbose "Inserting new record in $title"
  pass insert "$title" --multiline << EOF
{
  "created": "`date +%s`"
}
EOF
  cleanup
fi
# }}}
# Retrieve {{{1
if [[ -n "$get" ]]; then
  verbose "Extracting $key from $title"
  getpw "$key" "$title"
fi
# }}}
# select {{{1
if [[ -n "$select" ]]; then
  verbose "Selecting in $title"
  pass show "$title"
  cleanup
fi
# }}}
# Update {{{1
if [[ -n "$update" ]]; then
  verbose "Updating $key in $title with $keyvalue"
  updatekey "$key" "$title" "$tmpfile" "$keyvalue"
  cleanup
fi
# }}}
# Delete {{{1
if [[ -n "$del" ]]; then
  cleanup
fi
# }}}
# Generate {{{
if [[ -z "$passlen" ]]; then
  # If a password length was not specified, default to 20
  passlen=20
fi

if [[ -n "$passgen" ]]; then
  if ! type pwgen &> /dev/null; then echo "ERROR: Missing dependency: pwgen" 1>&2; exit 1; fi
  updatekey "password" "$title" "$tmpfile" "$(pwgen -c -n -s -1 "$passlen")"
  cleanup
fi
# }}}
# xkey type {{{1
if [[ -n "$xkey" ]]; then
  if ! echo "type $(getpw "$key" "$title")" | xdotool - ; then
    error "FATAL: error with xdotool"
    exit 1
  fi
  cleanup
fi
# 1}}}

error "ERROR: No command recognized."
error "Use xkeypass -? for usage instructions."
exit 1
# vim: ft=sh foldmethod=marker :
